<!DOCTYPE html>
<html lang="ch">
<head>
  <meta charset="UTF-8">
  <title>AJAx</title>
</head>

<script type="text/javascript">
/**AJAX(Asynchronous JavaScript and XML 异步的JavaScript和XML)**/
// AJAX不是新的编程语言,而是一种使用现有标准的新方法 AJAX是与服务器交换数据并更新部分网页的艺术,在不重新加载整个页面的情况下。
//     AJAX的工作原理相当于在用户和服务器之间加了—个中间层(AJAX引擎)，使用户操作与服务器响应异步化
// 创建XMLHttpRequest对象
let xmlhttp;
if (window.XMLHttpRequest) {
  // code for IE7+, Firefox, Chrome, Opera, Safari
  xmlhttp = new XMLHttpRequest();
} else {
  // code for IE6, IE5
  xmlhttp = new ActiveXObject("Microsoft.XMLHTTP");
}
// 属性
//   onreadystatechange  存储函数(或函数名),每当readyState的属性改变时,就会调用该函数 用此属性实现响应
//   readyState	  存有的XMLHttpRequest的状态从0到4发生变化。
//     0:请求未初始化   此阶段确认XMLHttpRequest对象是否创建,并为调用open()方法进行未初始化作好准备,
//        值为0表示对象已经存在,否则浏览器会报错:对象不存在。
//     1:服务器连接已建立   此阶段对XMLHttpRequest对象进行初始化,即调用open()方法,根据参数(method,url,true)
//        完成对象状态的设置.并调用send()方法开始向服务端发送请求.值为1表示正在向服务端发送请求
//     2:请求已接收     此阶段接收服务器端的响应数据.但获得的还只是服务端响应的原始数据,并不能直接在客户端使用.
//        值为2表示已经接收完全部响应数据，并为下一阶段对数据解析作好准备。
//     3:请求处理中     此阶段解析接收到的服务器端响应数据,即根据服务器端响应头部返回的MIME类型把数据转换成能通过responseBody,
//        responseText或responseXML的属性存取的格式,为在客户端调用作好准备.状态3表示正在解析数据。
//     4:请求已完成,且响应已就绪  此阶段确认全部数据都已经解析为客户端可用的格式,解析已经完成。
//        值为4表示数据解析完毕，可以通过的XMLHttpRequest对象的属性取得数据。
//     onreadystatechange事件被触发 5 次（0 - 4），对应着readyState的每个变化。
//         0：请求未初始化，还没有调用 open()。
//         1：请求已经建立，但是还没有发送，还没有调用 send()。
//         2：请求已发送，正在处理中（通常现在可以从响应中获取内容头）。
//         3：请求在处理中；通常响应中已有部分数据可用了，没有全部完成。
//         4：响应已完成；您可以获取并使用服务器的响应了。
//   response     响应主体
//   responseText	响应主体 以文本形式返回响应 只有readyState==4,responseText才可用,因为这时AJAX请求已结束
//   responseXML	响应主体 以XML格式返回响应 如果服务器的响应是XML,而且需要作为XML对象进行解析,请使用responseXML
//   status       将状态返回为数字（例如，“Not Found”为404，“OK”为200）
//   statusText   以字符串形式返回状态（例如，“Not Found”或“OK”）
// 方法
//   abort()      取消当前请求。
//   getAllResponseHeaders()          以字符串形式返回完整的HTTP标头集。
//   getResponseHeader( headerName )  返回指定HTTP标头的值。
//   void open(请求类型,URL)	          打开指定获取或交的方法和URL的请求。
//   void open(请求类型,URL,async)	  与上面相同，但指定异步或不。 true异步|false同步
//   void open(请求类型,URL,async,userName,password)  与上面相同，但指定用户名和密码。
//   void send(content）	          发送获取请求。
//   setRequestHeader(label,value)    将标签/值对添加到要发送的HTTP标头。
// GET
//    更简单更快 大部分情况下都能用
//    请求可被缓存
//    请求保留在浏览器历史记录中
//    请求可被收藏为书签
//    请求不应在处理敏感数据时使用
//    请求有长度限制
//    请求只应当用于取回数据
// POST
//    可更新服务器上的文件或数据库
//    可发送大量数据(POST没有数据量限制)
//    发送包含未知字符的用户输入时，POST比GET更稳定也更可靠
xmlhttp.onreadystatechange = function() { // 当async==false时不要写这个函数,把想执行的代码放到send()后面
  if (xmlhttp.readyState === 4 && xmlhttp.status === 200)
  {
    console.log(xmlhttp);
    console.log(xmlhttp.response);
  }
}
// xmlhttp.open("GET","https://news-at.zhihu.com/api/4/news/latest",true);

xmlhttp.open("POST","https://www.w3cschool.cn/index/getNotelist",true);
// 如果需要像HTML表单那样POST数据要加这个 然后在send()方法中规定您希望发送的数据
xmlhttp.setRequestHeader("Content-type","application/x-www-form-urlencoded");

xmlhttp.send("xing=jin&name=taiyan");


/**
 * 创建一个ajax工具类.
 */
function aJax(url, fnSuccess, fnFailed){
  var xhr = new XMLHttpRequest();
  xhr.open("get", url, true);
  xhr.send(null);
  xhr.onreadystatechange = function(){
    if(xhr.readyState === 4){
      if(xhr.status >= 200 && xhr.status < 300 || xhr.status === 304){
        fnSuccess(xhr.responseText);
      }else{
        if(fnFailed){
          fnFailed(xhr.status);
        }
      }
    }
  };
}
</script>

<body>
  使用的知乎api，会有跨域问题，解决办法
  https://www.cnblogs.com/laden666666/p/5544572.html
</body>
</html>