<!DOCTYPE html>
<html>
<head>
  <meta charset="UTF-8">
  <title>正则表达式</title>
</head>
<body>
<script type="text/javascript">
//RegExp 正则表达式 使用单个字符串来描述,匹配一系列符合某个句法规则的字符串搜索模式
//  修饰符
//    i ignoreCase的缩写，忽略字母的大小写
//    m multiline的缩写，更改^和$的含义，使它们分别在任意一行的行首和行尾匹配 而不仅仅在整个字符串的开头和结尾匹配。
//      (在此模式下,$的精确含意是:匹配\n之前的位置以及字符串结束前的位置.)
//    g	global的缩写，进行全局匹配，即对字符串进行全文匹配，直到字符串遍历结束
//  元字符
//    .             所有字符
//    \d            数字（0-9）
//    \s            空格字符、换行符
//    \w            数字、字母、下划线
//    \b            单词的边界
//    $             结尾
//    |             或者
//  反义字符
//    \D            非数字
//    \S            非空格字符
//    \W            非（数字、字母、下划线）
//    \B            非单词的边界
//    [^0-9]        非数字
//  量词(贪婪)(匹配优先量)  如果符合要求就一直往后匹配，一直到无法匹配为止,匹配过程将从整个字符串开始,不合适,就从后往前删
//    *         至少零个
//    +         至少一个
//    ？        至少零个，至多一个（可有可无）
//    {m}       刚好m个
//    {m,}      至少m个
//    {m,n}     至少m个，至多n个
//    [0-9A-Za-z]   数字0-9 字母      - 代表范围
//    [abc]p        ap bp cp []代表里面字符的其中一个
//  量词(惰性|非贪婪|勉强)(忽略优先量词) 一旦匹配到合适的就结束，不在继续匹配下去,从前往后加
//    *?  重复任意次，但尽可能少的重复
//    +?	重复一次或多次，但尽可能少的重复
//    ??	重复零次或一次，但尽可能少的重复
//    {n}?  重复n次，但尽可能少的重复
//    {n,}?	重复n次以上，但尽可能少的重复
//    {m,n}?	重复m到n次，但尽可能少的重复
//  分组/捕获/反引用
//    ()        分组(整体) 每个分组将产生分组号，从第一个括号开始，可以使用\n的形式在正则中使用分组号，
//                    如匹配成对出现的HTML标签，可以写成：/<(\w+)><\/\1>/  这个\1就是第一个分组
//    (?:aaa)	  匹配aaa正则，但不产生分组号
//      var str = "1234 5678";          //5678 1234
//      var reg = /(\d{4}) (\d{4})/g; // 这里分了两个组
//      reg.test(str); // 一定要有此步骤，下面的RegExp识别的是构造对象,没有此步骤就不知道你要的是哪个正则对象
//      console.log(RegExp.$1, RegExp.$2); // 1234 5678 反引用
//      document.writeln(str.replace(reg, "$2 $1"));      //5678 1234
//    aa1(?=aa2)	前瞻断言,匹配aa1,但后面必须是aa2 如匹配名字叫xianlie,但不姓zhao的人 /zhao(?=xianlie)/
//    aa1(?!=aa2)	后瞻断言,匹配aa1,但后面不能是aa2 如匹配姓zhao,但名字不叫xianlie的人 /zhao(?!xianlie)/


//  转义字符
//    \xnn	匹配十六进制数
//    \f	匹配换页符，等同于：\x0c
//    \n	匹配换行符，等同于：\x0a
//    \r	匹配回车符，等同于：\x0d
//    \t	匹配水平制表符，等同于：\x09
//    \v  匹配垂直制表符，等同于：\x0b
//    \unnnn	匹配Unicode字符，如：\u00A0

// 方法
//     compile	    编译正则表达式。
//     reg.test(str) 检测一个字符串是否匹配某个模式，如果字符串中含有匹配的文本，则返回 true，否则返回 false。
//     reg.exec(str) 检索字符串中的正则表达式的匹配。该函数返回一个数组，其中存放匹配的结果。如果未找到匹配，则返回值为 null。
//     str.match	 一个在字符串中执行查找匹配的String方法，它返回一个数组或者在未匹配到时返回null。
//     str.search	 一个在字符串中测试匹配的String方法，它返回匹配到的位置索引，或者在失败时返回-1。
//     str.replace(规则，替换文本)	一个在字符串中执行查找匹配的String方法，并且使用替换字符串替换掉匹配到的子字符串。
//     str.split	  一个使用正则表达式或者一个固定字符串分隔一个字符串，并将分隔后的子字符串存储到数组中的String方法。

// 属性
//     global      RegExp对象是否具有标志g
//     ignoreCase  RegExp对象是否具有标志i
//     lastIndex   整数,代表下次匹配将从哪个字符串位置开始,上次匹配完的下一个字符
//     multiline   RegExp对象是否具有标志m
//     source      正则表达式的源文本。

// 创建
//   var str = "Regular Expression";
//   var reg = new RegExp("G","i");    //i(ignore)忽略大小写      对象方式
//   var reg = /G/i;      //字面量方式 /元字符+量词/修饰符 == 匹配字符有多少个g+忽略大小写
//   document.writeln(str.search(reg));  // 多行匹配
  var str = "date:2018/01/31 time:11:02:25";
  var reg = /\d+/g;               //g(global) 找出所有满足条件的字符串
  document.writeln(str.match(reg));


</script>

匹配时分秒 <input type="text" pattern="^([01]\d|2[0-3])(:[0-5]\d){2}$" name="time" required>
</body>
</html>
